
------------------------------------------------------------------------
--  armskill.lua - Create skill module automatically for arm actions
--
--  Created: Wed Sep 01 16:30:45 2010
--  Copyright  2010  Tim Niemueller [www.niemueller.de]
--
------------------------------------------------------------------------

--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU Library General Public License for more details.
--
--  Read the full text in the LICENSE.GPL file in the doc directory.

require("fawkes.modinit")

--- Skill module auto-generator for ROS simple actions.
-- This module can automatically generate skill modules for simple ROS
-- actions which do not need special treatment.
-- @author Tim Niemueller
module(..., fawkes.modinit.module_init)

local skillenv = require("skiller.skillenv")
require("actionlib")
require("skiller.ros.action_jumpstate")
require("skiller.skillhsm")
require("skiller.ros.action_skill")
--require("herb_skills.utils.armctrl")
require("fawkes.fsm.jumpstate")
local ActionJumpState = skiller.ros.action_jumpstate.ActionJumpState
local JumpState = assert(fawkes.fsm.jumpstate.JumpState, "JumpState not specified!?")
local SkillHSM = skiller.skillhsm.SkillHSM

debug = skiller.ros.action_skill.debug

local reserved= { left = false, right = false }

local function is_free(side)
   printf("Checking free[%s] = %s", side, tostring(reserved[side]))
   return not reserved[side]
end

local function reserve(side)
   printf("Reserving %s", side)
   assert(not reserved[side], "Arm already reserved")
   reserved[side] = true
end

local function free(side)
   printf("Freeing %s", side)
   reserved[side] = false
end

local function can_start()
   return reserved.left and reserved.right
end

function use(module_name, action_name, action_type)
   local M = {}
   local skill_name       = module_name:match(".([%w%d_]+)$")
   local action_var_base  = skill_name
   local action_spec      = actionlib.get_actionspec(action_type)
   local state_base       = skill_name:upper()

   local action_name_left  = "/manipulation/left_arm/" .. action_name
   local action_name_right = "/manipulation/right_arm/" .. action_name
   local action_var_left   = action_var_base.."_left"
   local action_var_right  = action_var_base.."_right"
   local state_left        = state_base .. "_LEFT"
   local state_right       = state_base .. "_RIGHT"

   skillenv.module_init(M)
   M.name = skill_name
   M.fsm  = SkillHSM:new{name=M.name, start="WAIT_GOALS", debug=debug}
   M.depends_actions = {
      {v=action_var_left,  name=action_name_left,  type=action_type},
      {v=action_var_right, name=action_name_right, type=action_type}
   }
   M.documentation = "Autogenerated skill for the " .. action_name .. " ("
      .. action_type .. ") arm action.\nThe skill provides the following "
      .. "parameters which you must\npass as named arguments to the skill "
      .. "call.\n\n"
      .. "side=left/right\n"
      .. skiller.ros.action_skill.param_doc(action_spec.goal_spec.fields)

   skillenv.skill_module(M)

   M.fsm:define_states{ export_to=M,
      closure={is_free=is_free, can_start=can_start},
      {"WAIT_GOALS", JumpState},
      {state_left,  ActionJumpState, action_client=M[action_var_left]},
      {state_right, ActionJumpState, action_client=M[action_var_right]}
   }

   M.fsm:add_transitions{
      {"WAIT_GOALS", "FAILED", "vars.side ~= \"left\" and vars.side ~= \"right\"",
       timeout={5, "FAILED", error="No second goal"},
       precond_only=true, dotattr={labelrotate=-90}},
      {"WAIT_GOALS", "FAILED", "not is_free(vars.side)",
       precond_only=true, dotattr={labelrotate=-90}},
      {"WAIT_GOALS", state_left,  "can_start() and vars.side == \"left\""},
      {"WAIT_GOALS", state_right, "can_start() and vars.side == \"right\""},
   }

   M.WAIT_GOALS.init =
      function (self)
	 reserve(self.fsm.vars.side)
      end

   M.reset =
      function ()
	 if M.fsm.vars.side then
	    free(M.fsm.vars.side)
	 end
	 M.fsm:reset()
      end

   _G[module_name] = M
   package.loaded[module_name] = M

   skillenv.use_skill(module_name)

   return M
end
